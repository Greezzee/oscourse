## 1. Планировщик процессов
В качестве алгоритма для планировщика для real-time процессов был выбран аналог SJF (Shortest Job First) с небольшими нововведениями: в качестве метрики было выбрано значение:
(deadline – remaining_max_job_time)
Чем меньше значение метрики, тем приоритетнее запуск данного процесса. Таким образом, чем меньше времени остаётся до запуска данного процесса прежде, чем подойдёт дедлайн, тем более вероятно, что он запустится.
Для реализации данного метода планирования в структуру Env были добавлены следующие поля:

```c
enum EnvClass env_class; - класс процесса, может быть REAL_TIME или USUAL
uint64_t period; - период, с которым процесс должен запускаться (переводиться в состояние ENV_RUNNING)
uint64_t deadline; - дедлайн, время с начала периода, за которое процесс должен отработать
uint64_t max_job_time; - оценка сверху для времени работы процесса от начала периода
uint64_t left_max_job_time; - оценка сверху оставшегося времени работы процесса в данном цикле
void *exceed_deadline_upcall; - апколл, регистрируемый пользователем и вызыввемый при превышении дедлайна
uint64_t last_launch_time; - время последнего запуска процесса (необходимо для расчёта оставшегося времени работы процесса)
uint64_t last_period_start_moment; - время старта последнего периода для процесса
```

## 2. Многопоточность
Для реализации многопоточности были внесены изменения в структуру процессов в JOS, а также добавлена структура Thr.
(Структуры представлены с учётом полей, необходимых для скедюлинга и ipc)
```c
struct Thr {
    struct Trapframe thr_tf; /* Saved registers */
    struct Thr* thr_next;    /* Next working Thr (NULL if the last one) of this Env */
    struct Thr* thr_next_free; /* next global free thread */
    thrid_t thr_id;          /* Unique environment identifier */
    envid_t thr_env;   /* owner env id */
    unsigned thr_blocking_status;
    int64_t thr_block; /* id of thread we are join or id of mutex we are waiting to unlock or timeout */
    unsigned thr_status;
    uint32_t thr_runs; /* Number of times thread has run */
    uintptr_t thr_stack_top;
    uint32_t fixed_priority;
};

struct Env {
    thrid_t env_thr_head;    /* First active thread of the env */
    thrid_t env_thr_cur;     /* Currently active thread */
    size_t env_thr_count;
    struct Env *env_link;    /* Next free Env */
    envid_t env_id;          /* Unique environment identifier */
    envid_t env_parent_id;   /* env_id of this env's parent */
    enum EnvType env_type;   /* Indicates special system environments */
    unsigned env_status;     /* Status of the environment */

    uint8_t *binary; /* Pointer to process ELF image in kernel memory */

    /* Address space */
    struct AddressSpace address_space;

    /* Exception handling */
    void *env_pgfault_upcall; /* Page fault upcall entry point */

    /* LAB 9 IPC */
    bool env_ipc_recving;    /* Env is blocked receiving */
    bool env_ipc_sending;    /* Env is blocked sending. If true, env_ipc_maxsz, env_ipc_value is info about sent data */
    uintptr_t env_ipc_dstva; /* VA at which to map received page */
    uintptr_t env_ipc_srcva; /* VA at which to map sent page */
    size_t env_ipc_maxsz;    /* maximal size of received/sent region */
    uint32_t env_ipc_value;  /* Data value sent to us / by us */
    envid_t env_ipc_from;    /* envid of the sender */
    envid_t env_ipc_to;      /* envid of the receiver */
    int env_ipc_perm;        /* Perm of page mapping received/sent */
    thrid_t env_ipc_thr;     /* Thread currently recv\send */
    uint64_t env_ipc_timeout;/* value of tsc when ipc recv/send is timeouted. 0 if there are no timeout */

    /* Sleep syscall */
    uint64_t env_sleep_timeout;

    /* Additional fields for real-time processes */
    enum EnvClass env_class;
    uint64_t period;
    uint64_t deadline;
    uint64_t max_job_time;
    uint64_t left_max_job_time;  /* shows how mush time process should work at this iteration of scheduling */
    void *exceed_deadline_upcall;

    uint64_t last_launch_time;  /* last moment when the process starts to work */
    uint64_t last_period_start_moment;
};
```

Внутри ядра JOS теперь присутствует список потоков, структура которого совпадает со структурой списка процессов. Любой процесс при создании нового потока берёт свободную структуру из этого списка. Общее количество доступных потоков определяется `NTHRS`. Каждый процесс может использовать не более `NTHRS_PER_ENV` потоков одновременно.

Уникальный `thr_id` формируется из 4-х частей: id процесса, к которому он принадлежит; биты уникальности (по аналогии с id процесса), id потока внутри данного процесса (используется для определения расположения стэка) и индекс в массиве всех потоков.

При создании потока, для него выделяется стэк по адресу `USTACK_TOP - id * USTACK_SIZE` размера `USTACK_SIZE`, где `id` - идендификатор потока внутри данного процесса. Таким образом мы получаем, что все потоки работают в одном адрессном пространстве, но при этом имеют раздельные стэки. При этом если поток каким-то образом получил адрес на стэке другого потока того же процесса, он может свободно обращаться к нему. Тем самым при создании потока можно передавать указатели на память, с которой созданный поток сможет работать. Аналогично выделяется свой стэк исключений для каждого потока, но при этом необходима регистрация upcall обработчика. Обработка исключений происходит в каждом потоке отдельно, но при этом сами обработчики общие на весь процесс

При удалении потока, память его стэка очищается, после чего на этом же месте может быть выделена память другого потока.

По умолчению теперь при создании процесса создаётся один поток - главный. Однако завершение главного потока не означает завершение всего процесса. Процесс будет завершён только когда все его потоки будут завершены.

Были добавлены системные вызовы:
* `sys_thr_create` - создаёт новый поток для текущего процесса. Данный вызов аналогичен sys_exofork в плане того, что полученный поток продолжает выполнение с той же точки, что и создавший его. Разница только в возвращаемом значении - родитель получит id потока, ребёнок - 0.
* `sys_thr_exit` - завершает текущий поток
* `sys_thr_cancel` - завершает другой поток, id которого дан. Можно отменить и текущий поток
* `sys_thr_join` - вводит поток в состояние ожидания завершения другого потока. Ожидание не является активным
* `sys_thr_sleep` - вводит в состояние сна указанный поток на данное время. Ожидание в сне не является активным - поток переходит в состояние NOT_RUNNABLE и ожидает, когда планировщик обработает его и сделает RUNNABLE

Также был добавлен вызов, усыпляющий весь процесс.

Библиотечные вызовы для работы с потоками:
* `jthread_create` - создаёт новый поток, который будет выполнять данную функцию с указанным аргументов. Функция имеет вид `void(*start_routine)(void*)` - т.е. ничего не возвращает
* `jthread_exit`, `jthread_cancel`, `jthread_join`, `jthread_sleep` - аналоичны сисколам, за тем исключением, что первый также проверяет, является ли он последним потоком процесса и, если да, закрывает все файловые дескрипторы

Были добавлены мьютексы. В ядре имеется список доступных мьютексов - организация та же, что у потоков или процессов. Системные вызовы для работы с мьютексами:
* `sys_mutex_create` - создаёт новый мьютекс, возвращая его глобальный id
* `sys_mutex_destroy` - уничтожает данный мьютекс, переводя его в класс свободных, который в последствии может быть выдан при другом вызове создания мьютекса
* `sys_mutex_block_thr` - блокирует текущий поток до тех пор, пока поток, заблокировавший мьютекс, не вызовет системный вызов `sys_mutex_unlock`. Если текущий поток является тем, что мьютекс заблокировал - данный вызов вернёт сообщение о том, что мьютекс уже был заблокирован им же, и блокировки не будет
* `sys_mutex_unlock` - снимает блокировку с мьютекса

На основе данных вызовов была реализована система рекурсивных и нерекурсивных мьютексов, которая состоит из вызовов
* `jthread_mutex_init`
* `jthread_mutex_destroy`
* `jthread_mutex_lock`
* `jthread_mutex_unlock`

При создании мьютекса указывается параметр - рекурсивным он будет или нет.
Для оптимизации использования мьютекса, если поток успешно его блокирует, никаких сисколов не вызывается. Сискол будет вызван только когда какой-то другой поток будет заблокирован этим мьютексом. Также и для разблокировки - никакие сисколы не вызываются, если ранее ни один поток не был заблокирован.

## 3. IPC с таймаутами
Системные вызовы `sys_ipc_try_send` и `sys_ipc_recv` были дополнены версиями `*_timed`, которые также принимают одно число - кол-во миллисекунд, после которых передача данных должна быть остановлены и должен быть возвращён `-E_TIMEOUT`.

Для реализации структура `Env` была расширена полями, которые отвечают данным, сохранёнными отправителем в случае, если не удалось сразу отправить сообщение.

Схема отправки следующая:
1) Проводим проверки данных, которые хотим отправить, аналогично варианту без таймаута
2) Если получатель находится в состоянии `env_ipc_recving` - сразу отправить ему данные, перевести его в состояние `RUNNABLE`, сам отправитель продолжает работу
3) Иначе, отправитель запоминает все данные, необходимые для отправки, в соответствующие поля, и становится `NOT_RUNNABLE`

Схема получения совпадает с вариантом без таймаута за тем исключением, что поле, соответствующее таймауту, заполняется

Для обработки IPC с таймаутом, в скедюлере при выборе следующего рабочего процесса, рассматриваются также и `NOT_RUNNABLE` процессы. Для них вызывается функция `env_process_not_runnable`, которая может в последствии сделать процесс `RUNNABLE` (например, при истечении таймаута - в `rax` процесса кладётся `-E_TIMEOUT`, тем самым заставляя его думать, что функция, сделавшая его `NOT_RUNNABLE`, вернула таймаут). Та же обработка производится и для спящих процессов.

Полностью аналогично работает ожидания в потоках, добавлена функция `thr_process_not_runnable`, которая проверяет состояния других потоков или мьютексов, разблокируя те, которые нужно.

## Тестирование
Были добавлены следующие пользовательские программы:
1) `itask_rt` - запускает 5 Real-Time процессов с разными периодами активации, таймаутами
2) `itask_rt_deadline` - аналогично, но 3 из процессов превышают дедлайн, запуская свой обработчик и становясь обычными процессами
3) `simple_change_class_test` - малый тест, который демонстрирует работу сискола для изменения класса процесса
4) `itask_sleep` - проверка работа системного вызова `sys_sleep` для процессов
5) `itask_threads` - проверка многопоточности. Использованы все вызовы, кроме мьютексов
6) `itask_mutex` - проверка работы рекурсивных и нерекурсивных мьютексов
7) `itask_ipc_timed` - проверка работы IPC с таймаутами. Присутствуют успешные передачи, передачи с таймаутам, передачи страниц памяти, передачи между версией с таймаутам и без таймаута, множественные передачи с таймаутами
